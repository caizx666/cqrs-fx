{"version":3,"sources":["../../src/repository/event_sourced_repository.js"],"names":["_saveHash","name","id","props","CLS","get","aggregateRoot","createAggregate","hasSnapshot","getSnapshot","snapshot","buildFromSnapshot","loadEvents","Version","eventsAfterSnapshot","length","buildFromHistory","evnts","Count","code","err","aggregateNotExists","msg","aggregate","indexOf","push","option","canCreateOrUpdateSnapshot","createOrUpdateSnapshot","events","uncommittedEvents","evt","saveEvent","publish","commit","Rollback"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;AAGA;;;;AACA;;AAGA;;AAIA;;;;;AAKE,oBAAc;AAAA;;AACZ,SAAKA,SAAL,GAAiB,EAAjB;AACD;;;;oCAEeC,I,EAAMC,E,EAAIC,K,EAAO;AAC/B,UAAIC,MAAM,oBAAUC,GAAV,CAAcJ,IAAd,CAAV;AACA,UAAI,CAACG,GAAD,IAAQ,CAAC,uBAAWA,GAAX,CAAb,EACE,OAAO,IAAP;AACF,gDAAWA,GAAX,iBAAeF,EAAf,oCAAsBC,KAAtB;AACD;;;;6FAESF,I,EAAMC,E;0CAAOC,K;AAAAA,e;;;;;;;;sBACjB,CAACF,IAAD,IAAS,CAACC,EAAV,IAAgB,CAAC,qBAASD,IAAT,CAAjB,IAAmC,CAAC,qBAASC,EAAT,C;;;;;iDAAqB,I;;;AACzDI,6B,GAAgB,KAAKC,eAAL,CAAqBN,IAArB,EAA2BC,EAA3B,EAA+BC,KAA/B,C;;oBACfG,a;;;;;iDAAsB,I;;;;;;;;;;;uBACG,mBAAiBE,WAAjB,CAA6BP,IAA7B,EAAmCC,EAAnC,C;;;;;;;;;;;;uBACP,mBAAiBO,WAAjB,CAA6BR,IAA7B,EAAmCC,EAAnC,C;;;AAAjBQ,wB;;AACJJ,8BAAcK,iBAAd,CAAgCD,QAAhC;;uBACgC,eAAmBE,UAAnB,CAA8BX,IAA9B,EAAoCC,EAApC,EAAwCQ,SAASG,OAAjD,C;;;AAA5BC,mC;;AACJ,oBAAIA,uBAAuBA,oBAAoBC,MAApB,GAA6B,CAAxD,EACET,cAAcU,gBAAd,CAA+BF,mBAA/B;;;;;AAEFR,8BAAcJ,EAAd,GAAmBA,EAAnB;;uBACkB,eAAmBU,UAAnB,CAA8BX,IAA9B,EAAoCC,EAApC,C;;;AAAde,qB;;sBACAA,SAAS,IAAT,IAAiBA,MAAMC,KAAN,KAAgB,C;;;;;AACnCZ,8BAAcU,gBAAd,CAA+BC,KAA/B;;;;;sBAEM;AACJE,wBAAMC,IAAIC,kBADN;AAEJC,wDAAgBpB,EAAhB;AAFI,iB;;;iDAKHI,a;;;;;;;;;;;;;;;;;;;+FAGEiB,S;;;;;sBACL,KAAKvB,SAAL,CAAewB,OAAf,CAAuBD,SAAvB,IAAoC,CAAC,C;;;;;;;;AAEzC,qBAAKvB,SAAL,CAAeyB,IAAf,CAAoBF,SAApB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAI0B,KAAKvB,S;;;;;;;;AAAtBM,6B;;sBACH,sBAAoB,mBAAiBoB,MAAjB,IAA2B,W;;;;;;uBACvC,mBAAiBC,yBAAjB,CAA2CrB,aAA3C,C;;;;;;;;;uBACF,mBAAiBsB,sBAAjB,CAAwCtB,aAAxC,C;;;AAGNuB,sB,GAASvB,cAAcwB,iB;;;;;wDACXD,M;;;;;;;;AAAPE,mB;;uBACD,eAAmBC,SAAnB,CAA6BD,GAA7B,C;;;;uBACA,cAASE,OAAT,CAAiBF,GAAjB,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAIJ,eAAmBG,MAAnB,E;;;;uBACA,cAASA,MAAT,E;;;sBACF,sBAAoB,mBAAiBR,MAAjB,IAA2B,W;;;;;;uBAC3C,mBAAiBQ,MAAjB,E;;;;;;;;;;;;;;;;;;;;;;;;;uBAKF,eAAmBC,QAAnB,E;;;sBACF,sBAAoB,mBAAiBT,MAAjB,IAA2B,W;;;;;;uBAC3C,mBAAiBS,QAAjB,E","file":"event_sourced_repository.js","sourcesContent":["import eventSourced from './event_sourced_repository';\r\nimport {\r\n  provider as snapshotProvider\r\n} from '../snapshot';\r\nimport aggregate from '../aggregate';\r\nimport {\r\n  storage as domainEventStorage\r\n} from '../event';\r\nimport {\r\n  isFunction,\r\n  isString\r\n} from '../utils';\r\nimport {\r\n  eventbus\r\n} from '../bus';\r\n\r\nexport default class {\r\n  constructor() {\r\n    this._saveHash = [];\r\n  }\r\n\r\n  createAggregate(name, id, props) {\r\n    let CLS = aggregate.get(name);\r\n    if (!CLS || !isFunction(CLS))\r\n      return null;\r\n    return new CLS(id, ...props);\r\n  }\r\n\r\n  async get(name, id, ...props) {\r\n    if (!name || !id || !isString(name) || !isString(id)) return null;\r\n    let aggregateRoot = this.createAggregate(name, id, props);\r\n    if (!aggregateRoot) return null;\r\n    if (snapshotProvider && await snapshotProvider.hasSnapshot(name, id)) {\r\n      let snapshot = await snapshotProvider.getSnapshot(name, id);\r\n      aggregateRoot.buildFromSnapshot(snapshot);\r\n      var eventsAfterSnapshot = await domainEventStorage.loadEvents(name, id, snapshot.Version);\r\n      if (eventsAfterSnapshot && eventsAfterSnapshot.length > 0)\r\n        aggregateRoot.buildFromHistory(eventsAfterSnapshot);\r\n    } else {\r\n      aggregateRoot.id = id;\r\n      let evnts = await domainEventStorage.loadEvents(name, id);\r\n      if (evnts != null && evnts.Count() > 0)\r\n        aggregateRoot.buildFromHistory(evnts);\r\n      else\r\n        throw {\r\n          code: err.aggregateNotExists,\r\n          msg: `领域对象(id=${id})未能在数据库中找到.`\r\n        };\r\n    }\r\n    return aggregateRoot;\r\n  }\r\n\r\n  async save(aggregate) {\r\n    if (this._saveHash.indexOf(aggregate) > -1)\r\n      return;\r\n    this._saveHash.push(aggregate);\r\n  }\r\n\r\n  async commit() {\r\n    for (let aggregateRoot of this._saveHash) {\r\n      if (snapshotProvider && snapshotProvider.option == 'immediate') {\r\n        if (await snapshotProvider.canCreateOrUpdateSnapshot(aggregateRoot)) {\r\n          await snapshotProvider.createOrUpdateSnapshot(aggregateRoot);\r\n        }\r\n      }\r\n      let events = aggregateRoot.uncommittedEvents;\r\n      for (let evt of events) {\r\n        await domainEventStorage.saveEvent(evt);\r\n        await eventbus.publish(evt);\r\n      }\r\n    }\r\n    // todo 这里需要事务\r\n    await domainEventStorage.commit();\r\n    await eventbus.commit();\r\n    if (snapshotProvider && snapshotProvider.option == 'immediate') {\r\n      await snapshotProvider.commit();\r\n    }\r\n  }\r\n\r\n  async rollback() {\r\n    await domainEventStorage.Rollback();\r\n    if (snapshotProvider && snapshotProvider.option == 'immediate') {\r\n      await snapshotProvider.Rollback();\r\n    }\r\n  }\r\n}\r\n"]}